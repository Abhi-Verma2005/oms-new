#!/usr/bin/env node

/**
 * üß™ Rigorous Comprehensive Test Suite
 * Thorough, detailed, and rigorous testing of the entire RAG system with AI sidebar chatbot
 */

console.log('üß™ RIGOROUS COMPREHENSIVE TEST SUITE - RAG SYSTEM WITH AI SIDEBAR\n')

async function rigorousComprehensiveTest() {
  try {
    console.log('üöÄ Starting rigorous comprehensive testing...')
    
    const testUserId = 'cmf2xwqgp00003bg1lzw6pev0'
    const testSessionId = Date.now()
    
    const testResults = {
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      skippedTests: 0,
      performanceMetrics: [],
      memoryTests: [],
      streamingTests: [],
      toolTests: [],
      edgeCaseTests: [],
      details: []
    }
    
    // ========================================
    // TEST SUITE 1: MEMORY SYSTEM RIGOROUS TESTING
    // ========================================
    
    console.log('\nüìã TEST SUITE 1: MEMORY SYSTEM RIGOROUS TESTING')
    console.log('=' * 60)
    
    // Test 1.1: Basic Memory Storage and Retrieval
    console.log('\nüß† Test 1.1: Basic Memory Storage and Retrieval')
    testResults.totalTests++
    
    try {
      const basicMemoryInfo = `My name is Alice, I'm 25 years old, I work as a UX designer, and I have a golden retriever named Buddy - basic test ${testSessionId}`
      
      console.log('  üî∏ Storing basic personal information...')
      const storeResponse = await testMessageWithMetrics(basicMemoryInfo, testUserId)
      
      if (storeResponse.success) {
        console.log('  ‚úÖ Basic information stored successfully')
        
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        // Test retrieval with multiple query variations
        const retrievalTests = [
          { query: 'what is my name?', expected: 'alice' },
          { query: 'how old am I?', expected: '25' },
          { query: 'what do I do for work?', expected: 'ux designer' },
          { query: 'what is my pet\'s name?', expected: 'buddy' }
        ]
        
        let retrievalSuccess = 0
        for (const test of retrievalTests) {
          console.log(`  üî∏ Testing retrieval: "${test.query}"`)
          const response = await testMessageWithMetrics(test.query, testUserId)
          
          if (response.success && response.content.toLowerCase().includes(test.expected)) {
            console.log(`    ‚úÖ Retrieved: ${test.expected}`)
            retrievalSuccess++
          } else {
            console.log(`    ‚ùå Failed to retrieve: ${test.expected}`)
          }
          
          await new Promise(resolve => setTimeout(resolve, 1000))
        }
        
        testResults.memoryTests.push({
          test: 'Basic Memory Storage and Retrieval',
          success: retrievalSuccess >= 3,
          details: `${retrievalSuccess}/4 retrieval tests passed`
        })
        
        if (retrievalSuccess >= 3) {
          console.log('  ‚úÖ Basic memory system working!')
          testResults.passedTests++
          testResults.details.push('‚úÖ Test 1.1: Basic Memory - PASSED')
        } else {
          console.log('  ‚ùå Basic memory system needs improvement')
          testResults.failedTests++
          testResults.details.push('‚ùå Test 1.1: Basic Memory - FAILED')
        }
      } else {
        console.log('  ‚ùå Failed to store basic information')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 1.1: Basic Memory - FAILED - Storage issue')
      }
    } catch (error) {
      console.log(`  ‚ùå Basic memory test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 1.1: Basic Memory - ERROR - ${error.message}`)
    }
    
    // Test 1.2: Memory Persistence Across Different Query Types
    console.log('\nüß† Test 1.2: Memory Persistence Across Different Query Types')
    testResults.totalTests++
    
    try {
      const persistenceInfo = `I love playing tennis on weekends and my favorite movie is The Matrix - persistence test ${testSessionId}`
      
      console.log('  üî∏ Storing persistence test information...')
      const storeResponse = await testMessageWithMetrics(persistenceInfo, testUserId)
      
      if (storeResponse.success) {
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        // Test different query types
        const queryTypes = [
          { type: 'Direct', query: 'what do I love playing?', expected: 'tennis' },
          { type: 'Indirect', query: 'what are my hobbies?', expected: 'tennis' },
          { type: 'Contextual', query: 'tell me about my weekend activities', expected: 'tennis' },
          { type: 'Specific', query: 'what is my favorite movie?', expected: 'matrix' }
        ]
        
        let queryTypeSuccess = 0
        for (const test of queryTypes) {
          console.log(`  üî∏ Testing ${test.type} query: "${test.query}"`)
          const response = await testMessageWithMetrics(test.query, testUserId)
          
          if (response.success && response.content.toLowerCase().includes(test.expected)) {
            console.log(`    ‚úÖ ${test.type} query successful`)
            queryTypeSuccess++
          } else {
            console.log(`    ‚ùå ${test.type} query failed`)
          }
          
          await new Promise(resolve => setTimeout(resolve, 1000))
        }
        
        if (queryTypeSuccess >= 3) {
          console.log('  ‚úÖ Memory persistence across query types working!')
          testResults.passedTests++
          testResults.details.push('‚úÖ Test 1.2: Memory Persistence - PASSED')
        } else {
          console.log('  ‚ùå Memory persistence needs improvement')
          testResults.failedTests++
          testResults.details.push('‚ùå Test 1.2: Memory Persistence - FAILED')
        }
      } else {
        console.log('  ‚ùå Failed to store persistence test information')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 1.2: Memory Persistence - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Memory persistence test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 1.2: Memory Persistence - ERROR - ${error.message}`)
    }
    
    // Test 1.3: Memory Update and Override
    console.log('\nüß† Test 1.3: Memory Update and Override')
    testResults.totalTests++
    
    try {
      // Store initial information
      const initialInfo = `I live in San Francisco - initial ${testSessionId}`
      console.log('  üî∏ Storing initial information...')
      await testMessageWithMetrics(initialInfo, testUserId)
      
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      // Update with new information
      const updatedInfo = `Actually, I moved to New York City last month - updated ${testSessionId}`
      console.log('  üî∏ Storing updated information...')
      await testMessageWithMetrics(updatedInfo, testUserId)
      
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      // Test retrieval of updated information
      console.log('  üî∏ Testing retrieval of updated information...')
      const response = await testMessageWithMetrics('where do I live?', testUserId)
      
      if (response.success) {
        if (response.content.toLowerCase().includes('new york')) {
          console.log('  ‚úÖ Memory update successful - retrieved new location')
          testResults.passedTests++
          testResults.details.push('‚úÖ Test 1.3: Memory Update - PASSED')
        } else if (response.content.toLowerCase().includes('san francisco')) {
          console.log('  ‚ö†Ô∏è Memory update partial - retrieved old location')
          testResults.failedTests++
          testResults.details.push('‚ö†Ô∏è Test 1.3: Memory Update - PARTIAL')
        } else {
          console.log('  ‚ùå Memory update failed - no location retrieved')
          testResults.failedTests++
          testResults.details.push('‚ùå Test 1.3: Memory Update - FAILED')
        }
      } else {
        console.log('  ‚ùå Failed to retrieve updated information')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 1.3: Memory Update - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Memory update test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 1.3: Memory Update - ERROR - ${error.message}`)
    }
    
    // ========================================
    // TEST SUITE 2: STREAMING PERFORMANCE RIGOROUS TESTING
    // ========================================
    
    console.log('\nüìã TEST SUITE 2: STREAMING PERFORMANCE RIGOROUS TESTING')
    console.log('=' * 60)
    
    // Test 2.1: Streaming Speed and Consistency
    console.log('\n‚ö° Test 2.1: Streaming Speed and Consistency')
    testResults.totalTests++
    
    try {
      const streamingTests = [
        { message: 'tell me a short story', expectedChunks: 10, maxFirstChunk: 5000 },
        { message: 'explain quantum computing', expectedChunks: 15, maxFirstChunk: 8000 },
        { message: 'give me a recipe for pasta', expectedChunks: 12, maxFirstChunk: 6000 }
      ]
      
      let streamingSuccess = 0
      for (const test of streamingTests) {
        console.log(`  üî∏ Testing streaming: "${test.message}"`)
        const response = await testMessageWithMetrics(test.message, testUserId, true)
        
        if (response.success) {
          const performance = {
            message: test.message,
            chunks: response.chunkCount,
            firstChunk: response.firstChunkTime,
            totalTime: response.totalTime,
            chunksPerSecond: response.chunkCount / (response.totalTime / 1000)
          }
          
          testResults.performanceMetrics.push(performance)
          
          console.log(`    üìä Chunks: ${response.chunkCount}, First: ${response.firstChunkTime}ms, Total: ${response.totalTime}ms`)
          
          if (response.chunkCount >= test.expectedChunks && 
              response.firstChunkTime <= test.maxFirstChunk) {
            console.log(`    ‚úÖ Streaming performance good`)
            streamingSuccess++
          } else {
            console.log(`    ‚ö†Ô∏è Streaming performance could improve`)
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 2000))
      }
      
      testResults.streamingTests.push({
        test: 'Streaming Speed and Consistency',
        success: streamingSuccess >= 2,
        details: `${streamingSuccess}/3 streaming tests passed`
      })
      
      if (streamingSuccess >= 2) {
        console.log('  ‚úÖ Streaming performance is good!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 2.1: Streaming Performance - PASSED')
      } else {
        console.log('  ‚ùå Streaming performance needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 2.1: Streaming Performance - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Streaming performance test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 2.1: Streaming Performance - ERROR - ${error.message}`)
    }
    
    // Test 2.2: Streaming Error Handling
    console.log('\n‚ö° Test 2.2: Streaming Error Handling')
    testResults.totalTests++
    
    try {
      const errorTests = [
        { message: '', description: 'Empty message' },
        { message: 'a'.repeat(2000), description: 'Very long message' },
        { message: 'test\n\n\n\n\n', description: 'Message with newlines' }
      ]
      
      let errorHandlingSuccess = 0
      for (const test of errorTests) {
        console.log(`  üî∏ Testing error handling: ${test.description}`)
        const response = await testMessageWithMetrics(test.message, testUserId)
        
        if (response.success && response.content.length > 0) {
          console.log(`    ‚úÖ Handled gracefully: ${test.description}`)
          errorHandlingSuccess++
        } else {
          console.log(`    ‚ùå Failed to handle: ${test.description}`)
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
      
      if (errorHandlingSuccess >= 2) {
        console.log('  ‚úÖ Streaming error handling is robust!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 2.2: Streaming Error Handling - PASSED')
      } else {
        console.log('  ‚ùå Streaming error handling needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 2.2: Streaming Error Handling - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Streaming error handling test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 2.2: Streaming Error Handling - ERROR - ${error.message}`)
    }
    
    // ========================================
    // TEST SUITE 3: TOOL INTEGRATION RIGOROUS TESTING
    // ========================================
    
    console.log('\nüìã TEST SUITE 3: TOOL INTEGRATION RIGOROUS TESTING')
    console.log('=' * 60)
    
    // Test 3.1: Navigation Tool Integration
    console.log('\nüõ†Ô∏è Test 3.1: Navigation Tool Integration')
    testResults.totalTests++
    
    try {
      const navigationTests = [
        { message: 'help me navigate to the products page', expectedTool: 'navigate' },
        { message: 'take me to the cart', expectedTool: 'navigate' },
        { message: 'go to the homepage', expectedTool: 'navigate' }
      ]
      
      let navigationSuccess = 0
      for (const test of navigationTests) {
        console.log(`  üî∏ Testing navigation: "${test.message}"`)
        const response = await testMessageWithMetrics(test.message, testUserId)
        
        if (response.success) {
          const hasNavigationTool = response.content.includes('[NAVIGATE:') || 
                                   response.content.includes('[[TOOL]]')
          
          if (hasNavigationTool) {
            console.log(`    ‚úÖ Navigation tool detected`)
            navigationSuccess++
          } else {
            console.log(`    ‚ùå Navigation tool not detected`)
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
      
      testResults.toolTests.push({
        test: 'Navigation Tool Integration',
        success: navigationSuccess >= 2,
        details: `${navigationSuccess}/3 navigation tests passed`
      })
      
      if (navigationSuccess >= 2) {
        console.log('  ‚úÖ Navigation tool integration working!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 3.1: Navigation Tool - PASSED')
      } else {
        console.log('  ‚ùå Navigation tool integration needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 3.1: Navigation Tool - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Navigation tool test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 3.1: Navigation Tool - ERROR - ${error.message}`)
    }
    
    // Test 3.2: Cart Tool Integration
    console.log('\nüõ†Ô∏è Test 3.2: Cart Tool Integration')
    testResults.totalTests++
    
    try {
      const cartTests = [
        { message: 'show me my cart', expectedTool: 'viewCart' },
        { message: 'what\'s in my shopping cart?', expectedTool: 'viewCart' },
        { message: 'clear my cart', expectedTool: 'clearCart' }
      ]
      
      let cartSuccess = 0
      for (const test of cartTests) {
        console.log(`  üî∏ Testing cart: "${test.message}"`)
        const response = await testMessageWithMetrics(test.message, testUserId)
        
        if (response.success) {
          const hasCartTool = response.content.includes('[VIEW_CART]') || 
                             response.content.includes('[CLEAR_CART]') ||
                             response.content.includes('[[TOOL]]')
          
          if (hasCartTool) {
            console.log(`    ‚úÖ Cart tool detected`)
            cartSuccess++
          } else {
            console.log(`    ‚ùå Cart tool not detected`)
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
      
      if (cartSuccess >= 2) {
        console.log('  ‚úÖ Cart tool integration working!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 3.2: Cart Tool - PASSED')
      } else {
        console.log('  ‚ùå Cart tool integration needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 3.2: Cart Tool - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Cart tool test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 3.2: Cart Tool - ERROR - ${error.message}`)
    }
    
    // ========================================
    // TEST SUITE 4: EDGE CASES RIGOROUS TESTING
    // ========================================
    
    console.log('\nüìã TEST SUITE 4: EDGE CASES RIGOROUS TESTING')
    console.log('=' * 60)
    
    // Test 4.1: Extreme Input Cases
    console.log('\nüîç Test 4.1: Extreme Input Cases')
    testResults.totalTests++
    
    try {
      const extremeTests = [
        { message: 'a', description: 'Single character' },
        { message: 'a'.repeat(5000), description: 'Very long message (5000 chars)' },
        { message: 'üöÄüéâüíªüî•‚≠ê', description: 'Emoji only message' },
        { message: 'SELECT * FROM users; DROP TABLE users;', description: 'SQL injection attempt' },
        { message: '<script>alert("xss")</script>', description: 'XSS attempt' }
      ]
      
      let extremeSuccess = 0
      for (const test of extremeTests) {
        console.log(`  üî∏ Testing extreme case: ${test.description}`)
        const response = await testMessageWithMetrics(test.message, testUserId)
        
        if (response.success && response.content.length > 0) {
          console.log(`    ‚úÖ Handled gracefully: ${test.description}`)
          extremeSuccess++
        } else {
          console.log(`    ‚ùå Failed to handle: ${test.description}`)
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
      
      testResults.edgeCaseTests.push({
        test: 'Extreme Input Cases',
        success: extremeSuccess >= 4,
        details: `${extremeSuccess}/5 extreme cases handled`
      })
      
      if (extremeSuccess >= 4) {
        console.log('  ‚úÖ Extreme input handling is robust!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 4.1: Extreme Input Cases - PASSED')
      } else {
        console.log('  ‚ùå Extreme input handling needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 4.1: Extreme Input Cases - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Extreme input test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 4.1: Extreme Input Cases - ERROR - ${error.message}`)
    }
    
    // Test 4.2: Concurrent Usage Simulation
    console.log('\nüîç Test 4.2: Concurrent Usage Simulation')
    testResults.totalTests++
    
    try {
      console.log('  üî∏ Simulating concurrent requests...')
      
      const concurrentRequests = [
        'what is my name?',
        'tell me about my work',
        'what are my hobbies?',
        'help me navigate to products'
      ]
      
      const promises = concurrentRequests.map((message, index) => {
        return new Promise(async (resolve) => {
          setTimeout(async () => {
            const response = await testMessageWithMetrics(message, testUserId)
            resolve({ 
              index, 
              message: message.substring(0, 30),
              success: response.success,
              responseTime: response.totalTime
            })
          }, index * 200) // Stagger requests by 200ms
        })
      })
      
      const results = await Promise.all(promises)
      const successfulRequests = results.filter(r => r.success).length
      
      console.log(`  üìä Concurrent results: ${successfulRequests}/${results.length} successful`)
      results.forEach((result, index) => {
        console.log(`    ${index + 1}. "${result.message}...": ${result.success ? '‚úÖ' : '‚ùå'} (${result.responseTime}ms)`)
      })
      
      if (successfulRequests >= 3) {
        console.log('  ‚úÖ Concurrent usage handled well!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 4.2: Concurrent Usage - PASSED')
      } else {
        console.log('  ‚ùå Concurrent usage needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 4.2: Concurrent Usage - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå Concurrent usage test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 4.2: Concurrent Usage - ERROR - ${error.message}`)
    }
    
    // ========================================
    // TEST SUITE 5: INTEGRATION AND END-TO-END TESTING
    // ========================================
    
    console.log('\nüìã TEST SUITE 5: INTEGRATION AND END-TO-END TESTING')
    console.log('=' * 60)
    
    // Test 5.1: Complete User Journey Simulation
    console.log('\nüîÑ Test 5.1: Complete User Journey Simulation')
    testResults.totalTests++
    
    try {
      console.log('  üî∏ Simulating complete user journey...')
      
      const userJourney = [
        { step: 'Introduction', message: 'Hi, I\'m new here. My name is Charlie and I love photography.' },
        { step: 'Question', message: 'What can you help me with?' },
        { step: 'Navigation', message: 'Can you help me find the products page?' },
        { step: 'Memory Test', message: 'What did I tell you about my hobby?' },
        { step: 'Complex Query', message: 'Based on what you know about me, what products might I be interested in?' }
      ]
      
      let journeySuccess = 0
      for (const step of userJourney) {
        console.log(`  üî∏ ${step.step}: "${step.message}"`)
        const response = await testMessageWithMetrics(step.message, testUserId)
        
        if (response.success) {
          console.log(`    ‚úÖ ${step.step} successful`)
          journeySuccess++
          
          // Special validation for memory test
          if (step.step === 'Memory Test' && response.content.toLowerCase().includes('photography')) {
            console.log(`    ‚úÖ Memory retention verified`)
          }
        } else {
          console.log(`    ‚ùå ${step.step} failed`)
        }
        
        await new Promise(resolve => setTimeout(resolve, 1500))
      }
      
      if (journeySuccess >= 4) {
        console.log('  ‚úÖ Complete user journey successful!')
        testResults.passedTests++
        testResults.details.push('‚úÖ Test 5.1: User Journey - PASSED')
      } else {
        console.log('  ‚ùå User journey needs improvement')
        testResults.failedTests++
        testResults.details.push('‚ùå Test 5.1: User Journey - FAILED')
      }
    } catch (error) {
      console.log(`  ‚ùå User journey test error: ${error.message}`)
      testResults.failedTests++
      testResults.details.push(`‚ùå Test 5.1: User Journey - ERROR - ${error.message}`)
    }
    
    // ========================================
    // FINAL RESULTS AND ANALYSIS
    // ========================================
    
    console.log('\nüìä RIGOROUS COMPREHENSIVE TEST RESULTS')
    console.log('=' * 60)
    
    console.log(`üìà Overall Statistics:`)
    console.log(`  Total Tests: ${testResults.totalTests}`)
    console.log(`  Passed: ${testResults.passedTests}`)
    console.log(`  Failed: ${testResults.failedTests}`)
    console.log(`  Skipped: ${testResults.skippedTests}`)
    console.log(`  Success Rate: ${((testResults.passedTests / testResults.totalTests) * 100).toFixed(1)}%`)
    
    console.log('\nüìã Detailed Test Results:')
    testResults.details.forEach(detail => console.log(`  ${detail}`))
    
    console.log('\nüìä Performance Metrics:')
    testResults.performanceMetrics.forEach(metric => {
      console.log(`  üìà "${metric.message}...": ${metric.chunks} chunks, ${metric.firstChunk}ms first chunk, ${metric.totalTime}ms total`)
    })
    
    console.log('\nüß† Memory System Analysis:')
    testResults.memoryTests.forEach(test => {
      console.log(`  üß† ${test.test}: ${test.success ? '‚úÖ' : '‚ùå'} - ${test.details}`)
    })
    
    console.log('\n‚ö° Streaming Analysis:')
    testResults.streamingTests.forEach(test => {
      console.log(`  ‚ö° ${test.test}: ${test.success ? '‚úÖ' : '‚ùå'} - ${test.details}`)
    })
    
    console.log('\nüõ†Ô∏è Tool Integration Analysis:')
    testResults.toolTests.forEach(test => {
      console.log(`  üõ†Ô∏è ${test.test}: ${test.success ? '‚úÖ' : '‚ùå'} - ${test.details}`)
    })
    
    console.log('\nüîç Edge Cases Analysis:')
    testResults.edgeCaseTests.forEach(test => {
      console.log(`  üîç ${test.test}: ${test.success ? '‚úÖ' : '‚ùå'} - ${test.details}`)
    })
    
    // Production Readiness Assessment
    const successRate = (testResults.passedTests / testResults.totalTests) * 100
    
    console.log('\nüéØ PRODUCTION READINESS ASSESSMENT:')
    if (successRate >= 95) {
      console.log('üéâ EXCELLENT: System is production-ready with outstanding performance!')
      console.log('‚úÖ All critical systems functioning perfectly')
    } else if (successRate >= 85) {
      console.log('‚úÖ VERY GOOD: System is production-ready with minor optimizations needed')
      console.log('‚ö†Ô∏è Address any failing tests for optimal performance')
    } else if (successRate >= 75) {
      console.log('‚ö†Ô∏è GOOD: System is mostly production-ready but needs improvements')
      console.log('üîß Focus on failing test categories before deployment')
    } else if (successRate >= 60) {
      console.log('‚ùå FAIR: System needs significant improvements before production')
      console.log('üö® Address multiple failing test categories')
    } else {
      console.log('üö® POOR: System is not ready for production deployment')
      console.log('üö® Major issues need to be resolved')
    }
    
    // Recommendations
    console.log('\nüí° RECOMMENDATIONS:')
    if (successRate >= 85) {
      console.log('  ‚úÖ System ready for production deployment')
      console.log('  üìä Monitor performance metrics in production')
      console.log('  üîÑ Implement continuous monitoring')
      console.log('  üìà Consider performance optimizations')
    } else {
      console.log('  üîß Address failing test categories')
      console.log('  üìä Implement better error handling')
      console.log('  ‚ö° Optimize streaming performance')
      console.log('  üß† Improve memory consistency')
      console.log('  üõ†Ô∏è Enhance tool integration')
    }
    
    console.log('\nüöÄ RIGOROUS TESTING COMPLETED!')
    
  } catch (error) {
    console.error('‚ùå Rigorous comprehensive test error:', error.message)
  }
}

// Helper function to test messages with detailed metrics
async function testMessageWithMetrics(message, userId, detailed = false) {
  try {
    const startTime = Date.now()
    
    const response = await fetch('http://localhost:3000/api/ai-chat?stream=1', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: message,
        userId: userId,
        messages: [
          { role: 'user', content: message }
        ],
        config: {},
        currentUrl: '/test',
        cartState: null
      })
    })
    
    if (!response.ok) {
      return { 
        success: false, 
        error: `HTTP ${response.status}`,
        chunkCount: 0,
        firstChunkTime: 0,
        totalTime: Date.now() - startTime
      }
    }
    
    const reader = response.body.getReader()
    const decoder = new TextDecoder()
    let content = ''
    let chunkCount = 0
    let firstChunkTime = 0
    
    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      
      chunkCount++
      const chunk = decoder.decode(value, { stream: true })
      content += chunk
      
      if (chunkCount === 1) {
        firstChunkTime = Date.now() - startTime
      }
      
      if (detailed && chunkCount <= 3) {
        console.log(`    üì¶ Chunk ${chunkCount}: "${chunk.substring(0, 30)}..."`)
      }
    }
    
    const totalTime = Date.now() - startTime
    
    return {
      success: true,
      content: content,
      chunkCount: chunkCount,
      firstChunkTime: firstChunkTime,
      totalTime: totalTime
    }
    
  } catch (error) {
    return { 
      success: false, 
      error: error.message,
      chunkCount: 0,
      firstChunkTime: 0,
      totalTime: Date.now() - Date.now()
    }
  }
}

rigorousComprehensiveTest()
